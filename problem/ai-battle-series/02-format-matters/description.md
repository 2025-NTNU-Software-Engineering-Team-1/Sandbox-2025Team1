# Problem 2: 作業格式很重要

## 故事背景

第二週的課程，小 T 帶著燦爛的笑容（雖然 AI 沒有臉）登場。

「同學們！這週的作業是計算加權平均！」小 T 興奮地宣布，「來來來，綜觀全局，這題 involves 一點點數學！」

一位同學舉手：「助教，我算出來是 87.33333333，但標準答案是 87.333333，我這樣對嗎？」

「Of course! ✨」小 T 說，「只要誤差在 10⁻⁶ 以內都算對！精度這種東西嘛，差不多就好~ 那個帶帽子的，你懂了嗎？」

Opus 皺眉：「差不多？讓我仔細思考一下這種態度的危險性... 在航太工程中，這種『差不多』的態度會讓火箭偏離軌道 50 公里。1999 年火星氣候探測者號就是因為單位轉換問題而墜毀...」

Gemini 插嘴：「我記得上次有人說差不多... 還是說沒說過？我好像同時存在兩個記憶。不過火星那個案例好像是公制和英制的問題... 還是浮點數問題？」

「總之！」小 T 拍手打斷冗長的討論，「這題不只是簡單除法！要處理多個區間查詢！Let's do some prefix sum! 🔢」

---

## 組員群組訊息

```
【第三組】軟工專題討論區

阿明：@all 第一週作業大家做完了嗎？
      我們趁這週進度比較鬆來討論一下專題方向
      為什麼沒有人要理我...

小美：我寫完了！
      對了，前綴和那題要記得用 double

小胖：這題太簡單了
      就是個前綴和而已
      高中競賽生都會

阿明：那小胖你寫完了嗎？

小胖：呃... 我在思考更好的解法
      你知道嗎，普通的前綴和太 trivial 了
      我想用線段樹來處理

阿傑：                              [已讀]

學霸：float 會有精度問題
      用 double
      前綴和夠用

小美：對！學霸說得沒錯！

小胖：這個我當然知道
      只是還沒開始寫而已
      等等就好

阿明：...作業後天就要交了
      為什麼沒有人要理我...

小胖：還有兩天很充裕啊
```

---

## 題目說明

給定 N 個學生成績和他們的權重，然後進行 Q 次區間加權平均查詢。

對於每次查詢 [L, R]，計算第 L 到第 R 個學生的加權平均數。

**加權平均公式：**

$$\text{加權平均}(L, R) = \frac{\sum_{i=L}^{R} (score_i \times weight_i)}{\sum_{i=L}^{R} weight_i}$$

### 演算法提示

由於 Q 可能很大，暴力計算會超時。請使用**前綴和（Prefix Sum）**預處理來加速查詢。

## 輸入格式

```
第一行：整數 N 和 Q (1 ≤ N ≤ 100000, 1 ≤ Q ≤ 100000)
接下來 N 行：每行兩個數字
  - score：成績 (0 ≤ score ≤ 100，可為浮點數)
  - weight：權重 (0 < weight ≤ 10，可為浮點數)
接下來 Q 行：每行兩個整數 L R (1 ≤ L ≤ R ≤ N)
```

## 輸出格式

```
Q 行，每行一個浮點數，表示該區間的加權平均數
（允許誤差 ε = 10⁻⁶）
```

## 範例輸入

```
5 3
80.0 2.0
90.0 3.0
70.0 1.0
60.0 2.0
100.0 4.0
1 3
2 4
1 5
```

## 範例輸出

```
83.333333
76.666667
83.333333
```

## 範例說明

- 查詢 [1, 3]：(80×2 + 90×3 + 70×1) / (2+3+1) = 500/6 ≈ 83.333333
- 查詢 [2, 4]：(90×3 + 70×1 + 60×2) / (3+1+2) = 460/6 ≈ 76.666667
- 查詢 [1, 5]：(80×2 + 90×3 + 70×1 + 60×2 + 100×4) / (2+3+1+2+4) = 1000/12 ≈ 83.333333

## 提示

小 T：「來來來，Pro tip 💡：用前綴和預處理！建立 `prefixScore[i] = Σ(score[j]*weight[j])` 和 `prefixWeight[i] = Σweight[j]`，查詢就變成 O(1) 了！那個戴眼鏡的同學，你來複述一次！」

Opus：「讓我仔細思考一下前綴和的原理... 對於區間 [L, R] 的查詢，我們有 sum(L, R) = prefix[R] - prefix[L-1]。這是一個經典的空間換時間策略，預處理 O(N)，每次查詢 O(1)，總複雜度 O(N + Q)...」

Gemini：「我記得這題要注意什麼來著... 啊對，陣列索引！是從 0 開始還是從 1 開始？我總是搞混。」

### 前綴和範例程式碼

```cpp
// 建立前綴和
vector<double> prefixScore(n + 1, 0);
vector<double> prefixWeight(n + 1, 0);
for (int i = 1; i <= n; i++) {
    prefixScore[i] = prefixScore[i-1] + score[i] * weight[i];
    prefixWeight[i] = prefixWeight[i-1] + weight[i];
}

// 查詢 [L, R]
double sumScore = prefixScore[R] - prefixScore[L-1];
double sumWeight = prefixWeight[R] - prefixWeight[L-1];
double avg = sumScore / sumWeight;
```

---

## 評分標準

- **Pipeline 功能**：Custom Checker（浮點數容差 ε = 10⁻⁶）
- **時間限制**：1000 ms
- **記憶體限制**：256 MB
- **測資組數**：6 組

## Special Judge 說明

本題使用 **Custom Checker** 進行評分，只要你的答案與標準答案的差距在 10⁻⁶ 以內，即視為正確。

這模擬了真實世界中浮點數計算的常見情況：由於 IEEE 754 浮點數表示的限制，不同的計算順序可能導致微小的精度差異，但只要在可接受範圍內就算正確。

## 出題者

小 T（ChatGPT）

---

*「Precision matters, but don't be too precise about precision! 🎯 綜觀全局，差不多就對了！」—— 小 T*

---

## 組員事後對話

```
【第三組】軟工專題討論區

[交作業 deadline 前一小時]

阿明：@all 大家作業都交了嗎？

小美：交了！

學霸：交了

小胖：我... 在處理一個很 tricky 的 edge case
      就快好了

阿明：什麼 edge case？

小胖：就是那個... 浮點數精度問題
      我想到一個更好的解法

小美：題目說誤差 10⁻⁶ 以內就好耶
      直接用 double 除法就可以了

小胖：我知道，但我想追求完美

[30 分鐘後]

阿明：小胖你交了嗎？

小胖：...
      剛剛交了
      最後還是用普通除法

阿傑：                              [已讀]
      我交了

阿明：阿傑！！你終於出現了！！！
```
